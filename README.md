# cf-ops-automation-broker [![CI](https://circleci.com/gh/orange-cloudfoundry/cf-ops-automation-broker.svg?style=shield&circle-token=:circle-token)](https://circleci.com/gh/orange-cloudfoundry/cf-ops-automation-broker)
On demand dedicated services through COA concourse pipeline engine

## Overview

COAB is a generic service broker which enables operators to provide on-demand dedicated services from available building blocks:
* terraform modules provisionning
   * [cloudfoundry resources](https://github.com/mevansam/terraform-provider-cf], such as cloudfoundry applications
   * [K8S resources](https://www.terraform.io/docs/providers/kubernetes/), e.g. through [K8S charts](https://github.com/mcuadros/terraform-provider-helm)
   * Saas resources such as [cloudflare](https://www.terraform.io/docs/providers/cloudflare/)
* existing bosh releases with shared services plans (e.g [cassandra-cf-service-boshrelease](https://github.com/orange-cloudfoundry/cassandra-cf-service-boshrelease/)

COAB leverages concourse based pipelines to deploy and operate the dedicated resources, managed by the [cf-ops-automation (COA)](https://github.com/orange-cloudfoundry/cf-ops-automation) collaboration framework.

The following diagram illustrates COAB interactions
![Overview of COAB interactions](coab-overview.png)

    1- A user requests a dedicated service instance (or binding) through its prefered platform (CF or K8S service catalog) which in turn propagate the request to COAB as an [OSB API call](https://github.com/openservicebrokerapi/servicebroker )
    2- COAB requests an on-demand dedicated pipeline to the COA templating engine, by writing to Git repos
    3- COA templating engine read the git repos 
    4- COA generates on-demand pipelines that deploys and operate the requested dedicate service resources
    5- The dedicated concourse pipeline provisions resources supporting the dedicated resource (in form of a bosh deployment, a terraform module, or a CF app)
    7- the dedicated concourse pipeline records the outcome of the dedicated service in git
    8- the dedicated concourse pipeline (and its underlying tools such as bosh director) records the credentials necessary to consumme the decicated service instance/binding
    9- COAB pulls the dedicated service provisionning completion status from git
    10a- COAB delegates OSB API calls to nested service brokers, delegating credentials management to them
    10b- alternatively COAB fetches dedicated service credentials generated by the pipeline from credhub
    11- COAB returns service instance/bindings to user





## Getting Started

A sample [service broker](cf-ops-automation-sample-broker) project is available.

Add dependencies to your project's build file. 

Maven example: 

    <dependencies>
        ...
          <dependency>
                    <groupId>com.orange.oss.cloudfoundry.broker.opsautomation</groupId>
                    <artifactId>cf-ops-automation-broker-core</artifactId>
                    <version>0.13.0-SNAPSHOT</version>
          </dependency>
        ...
    </dependencies>

This project uses the immutables library. See [related documentation](https://immutables.github.io/apt.html) on how to setup you IDE to perform annotation processing
   
    
## Configuring the broker

The framework requires the broker to just provide an implementation of a [`ProcessorChain` bean](cf-ops-automation-broker-framework/src/main/java/com/orange/oss/cloudfoundry/broker/opsautomation/ondemandbroker/processors/ProcessorChain.java).

    @SpringBootApplication
    public class Application {
    
        public static void main(String[] args) {
            SpringApplication.run(Application.class, args);
        }
         
        @Bean
        public ProcessorChain processorChain() {
            List<BrokerProcessor> processors=new ArrayList<BrokerProcessor>();
            processors.add(new DefaultBrokerProcessor());
            DefaultBrokerSink sink=new DefaultBrokerSink();
            ProcessorChain chain=new ProcessorChain(processors, sink);
            return chain;
        }
    }

## Configuring the service broker catalog

The framework requires the broker to just provide an implementation of a [`Catalog` bean](https://github.com/spring-cloud/spring-cloud-cloudfoundry-service-broker/blob/master/src/main/java/org/springframework/cloud/servicebroker/model/Catalog.java).

### Using @Configuration and @Bean to inject a Catalog bean

There is an example of this approach in the [sample broker](cf-ops-automation-sample-broker/src/main/java/com/orange/oss/cloudfoundry/broker/opsautomation/ondemandbroker/sample/BrokerCatalogConfig.java).

    @Configuration
    public class BrokerCatalogConfig {
    	@Bean
    	public Catalog catalog() {
    		return new Catalog(Collections.singletonList(
    				new ServiceDefinition(
    						"ondemand-service",
    						"ondemand",
    						"A simple ondemand service broker implementation",
    						true,
    						false,
    						Collections.singletonList(
    								new Plan("ondemand-plan",
    										"default",
    										"This is a default ondemand plan.  All services are created equally.",
    										getPlanMetadata())),
    						Arrays.asList("ondemand", "document"),
    						getServiceDefinitionMetadata(),
    						null,
    						null)));
    	}
    }

### Using spring-boot-starter-servicebroker-catalog to configure your service broker catalog

[spring-boot-starter-servicebroker-catalog](spring-boot-starter-servicebroker-catalog) provides an opinionated spring boot 'starter' to simplify your catalog configuration.

To benefit from the starter , add it to your POM:

        <dependency>
            <groupId>com.orange.oss.cloudfoundry.broker.opsautomation</groupId>
            <artifactId>spring-boot-starter-servicebroker-catalog</artifactId>
            <version>last_version</version>
        </dependency>
        
You can then configure the [`Catalog`](https://github.com/spring-cloud/spring-cloud-cloudfoundry-service-broker/blob/master/src/main/java/org/springframework/cloud/servicebroker/model/Catalog.java)
using properties files, YAML files, environment variables or command-line arguments.
There is an example of this approach in the [sample broker](cf-ops-automation-sample-broker/src/main/resources/application.yml).

Please, notice that you can also use `CATALOG_YML` environment variable to set catalog config in a YAML format.

```shell
#export catalog.yml file content as an env variable
export CATALOG_YML="$(cat catalog.yml)"

```

See [catalog.yml](cf-ops-automation-sample-broker/catalog.yml) for details.

## Contributions

 ### Releasing

Prereqs: checkout the branch to release, and make sure it is up-to-date w.r.t. the github remote.
 
Releasing is made using [maven release plugin](http://maven.apache.org/maven-release/maven-release-plugin/) as follows :
 
 ```shell
 
 $ mvn release:prepare --batch-mode -Dtag={your git tag} -DreleaseVersion={release version to be set} -DdevelopmentVersion={next snapshot version to be set}
 
 # ex : mvn release:prepare --batch-mode -Dtag=v0.21.0 -DreleaseVersion=0.21.0 -DdevelopmentVersion=0.22.0-SNAPSHOT
 
 ```
 
 Circle CI build will proceed, and will trigger the execution of `mvn release:perform`, and upload artifacts to both github and https://bintray.com/elpaaso. For further details, see [release:prepare goals](http://maven.apache.org/maven-release/maven-release-plugin/prepare-mojo.html)

Following the release:
- edit the release notes in github
- clean up your local workspace using `mvn release:clean`

In case of issues, try:
* `mvn release:rollback` 
    * possibly revert the commits in git (`git reset --hard commitid`), 
* clean up the git tag `git tag -d vXX && git push --delete origin vXX`, 
* `mvn release:clean`
* fix the root cause and retry.
 
